---
# page
title: "[OS] 프로세스 개념 정리 #2"
excerpt: "컴퓨터를 이해해보기 - OS편"
layout : single
published: true
# classes: wide

# toc
toc: true
toc_sticky: true
toc_label: "목차"

# category & tag
categories:
  - OS
tags: 
  - OS
  - Process
  - Thread

# Time
read_time: true
date: 2021-11-10 
last_modified_at: 2021-11-10
---

## :fire: 목표
> **1. 선점, 비선점 정책**  
> **2. 효율적인 프로세스 관리를 위한 스케줄링 방법**  
> **3. 교착 상태의 발생 조건과 관리법**  
> **4. 프로세스 VS 스레드**  


## :speech_balloon: 1. 선점, 비선점

 **간단하게 OS 기준으로 선점이 가능한지 불가능한지 생각하면 간편하다.**  
 + 선점 : OS가 CPU 사용권을 선점할 수 있고, 강제 회수 가능
 + 비선점 : OS가 CPU 사용권을 선점할 수 없음, 프로세스 종료 또는 I/O 이벤트가 있을 때 까지 실행 보장 

따라서 OS는 프로세스를 아래와 같은 상태로 관리한다.
![프로세스상태](https://user-images.githubusercontent.com/13609011/91695344-f2dfae80-eba8-11ea-9a9b-702192316170.jpeg)
 + Interrupt, Dispatch : 선점 스케줄링
 + I/O 또는 프로세스 종료 같은 이벤트 : 비선점 스케줄링  

## :speech_balloon: 2. 프로세스 스케줄링 

  > **프로세스를 스케줄링 하는 목적은 CPU를 쉬지 않고 효율적 사용을 기초로, 균형있는 자원 사용과 처리율 증가, 오버헤드,응답시간,반환시간 최소화 등의 목적을 가진다.**  

  따라서 위의 선점, 비선점 스케줄링 기법을 통해 프로세스 상태를 관리한다.  

 + 선점 스케줄링  
    - 장점 : 우선순위가 높은 프로세스를 빠르게 처리 가능, 시분할 시스템에 용이   
    - 단점 : 많은 오버헤드를 초래, 인터럽트용 타이머 클록이 필요  
    - 예시 : RoundRobin, Priority Scheduling
 + 비선점 스케줄링  
    - 장점 : 응답시간 예측이 편하고, 일괄처리 방식에 적합
    - 단점 : 중요한 작업이 와도 우선 처리 불가  
    - 예시 : FCFS, SJF, HRN  

## :speech_balloon: 3. 교착상태 

> **선점, 비선점 스케줄링을 통해 프로세스 간 상태 변경이 발생하고, 그리고 프로세스간 공유메모리, 메시지 패싱 등을 통한 통신이 발생하며, 다수의 프로세스가 사용하는 시스템 자원의 요구가 뒤엉킨 상황이 발생합니다.**  

이렇게 뒤엉킨 상황 중에서 둘 이상의 프로세스가 다른 프로세스가 점유하고
있는 자원을 서로 무한으로 기다릴 때   해당 상황을 교착 상태라고 합니다.  
(직장 내에서 자주 일어나는 상황이죠...)  

**위의 교착 상태가 발생하는 조건은 크게 4가지 입니다.**  
1. 한 자원은 하나의 프로세스만 사용할 수 있다 (상호 배제)  
2. 프로세스가 자원을 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기 (점유 대기)  
3. 이미 할당된 자원을 강제로 뺏을 수 없다 (비선점)  
4. 대기하는 프로세스들이 순환 형태로 자원을 할당 받기를 기다린다 (순환 대기)  

**위의 조건으로 발생할 수 있는 교착 상태를 해결하기 위한 해결 정책은 크게 3개로 분류가 됩니다.**  
1. 교착 상태가 발생하지 않도록 **예방**   
   + (위의 4가지 조건 중 하나라도 부정)
2. 교착 상태는 발생할 수 있으니 **회피**   
   + (자원을 모두 잘 쓸수 있는 정책 생성[은행원알고리즘])  
3. 교착 상태는 발생하니까 탐지하고 **회복**   
   + (그래프를 통한 탐지,순한대기 탈출)  
 
## :speech_balloon: 4. 프로세스vs스레드

![스레드](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Multithreaded_process.svg/1024px-Multithreaded_process.svg.png)
  
프로세스는 일반적으로 독립적인 상태로 프로세스 내에 아래와 같은 5가지 영역으로 분류가 됩니다.
1. CODE
2. DATA
3. HEAP
4. 메인스레드
5. 메인스레드 내 STACK  
  
스레드는 일반적으로 프로세스의 하위 집합으로 프로세스 내에서 메인스레드를 제외하고 다수 개 생성이 가능합니다.  

**프로세스와 스레드 큰 차이점은** 
**스레드는 CODE, DATA, HEAP 영역은 서로 공유하고, 각 스레드 내에는** **STACK영역을 독립적으로 가지고 있다는 점 입니다.**  
**또한 프로세스 보다 가볍고, 스레드 간의 Context-Switch는 프로세스보다 더 빠르다는 장점이 있습니다.**

프로세스 대비 스레드의 장/단점을 비교하면
> **스레드의 장점**
+ **리소스 감소** : 스레드를 사용하면 멀티 프로세스 환경 보다 적은 리소스를 사용해서 어플리케이션을 작동할 수 있습니다.
+ **통신, 공유 간소화** : 스레드는 CODE,DATA 영역을 공유하기 때문에 통신 리소스가 감소합니다.  


> **스레드의 단점**
+ **디버깅이 어렵다** : 자체 주소 공간을 가지고 있지 않고, 프로세스 하위에 있기 때문에 프로그램 디버깅이 어렵습니다.
+ **영향도 전파** : 하나의 스레드에 문제가 생기면 전체적인 프로세스에 영향을 끼칩니다. 


## :memo: 결론

> **1. 선점(뺏을 수 있다), 비선점(뺏을 수 없다)**   
> **2. 프로세스 스케줄링 : 선점(시분할,RR), 비선점(배치,FCFS)**   
> **3. 교착상태 : 상호배제, 점유대기, 비선점, 순환대기**  
> **4. 프로세스 VS 스레드 : 스레드 가볍다, 프로세스 독립적이다**    

## :question: 추후 공부할 것
**1. 동시성 처리에 대한 해결 방안 (RaceCondition,세마포어,뮤텍스)**  


